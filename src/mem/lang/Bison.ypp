%parse-param{mem::fs::FileManager& fm}
%parse-param{mem::ast::node::Node* ast}
%parse-param{mem::st::SymbolTable& symbols}
%parse-param{mem::log::Logger* logger}
%parse-param{mem::fs::File* file}

%code requires{
#define PASS (0);
#include <stdio.h>
#include <string.h>
#include "mem/ast/node/BinaryExpression.hpp"
#include "mem/ast/node/BinaryOp.hpp"
#include "mem/ast/node/Block.hpp"
#include "mem/ast/node/Call.hpp"
#include "mem/ast/node/Class.hpp"
#include "mem/ast/node/Dot.hpp"
#include "mem/ast/node/Field.hpp"
#include "mem/ast/node/FinalId.hpp"
#include "mem/ast/node/New.hpp"
#include "mem/ast/node/Primitive.hpp"
#include "mem/ast/node/Root.hpp"
#include "mem/ast/node/Text.hpp"
#include "mem/ast/node/Use.hpp"
#include "mem/ast/node/VarAssign.hpp"
#include "mem/ast/node/VarDecl.hpp"
#include "mem/ast/node/While.hpp"
#include "mem/fs/File.hpp"
#include "mem/fs/FileManager.hpp"
#include "mem/fs/position/Range.hpp"
#include "mem/log/Logger.hpp"
#include "mem/st/SymbolTable.hpp"
#include "mem/Compiler.hpp"
#include "mem/number.hpp"

using namespace mem;

#ifndef YYERROR_VERBOSE
#define YYERROR_VERBOSE 1
#endif

#define YYLTYPE fs::position::Range
#define YYLTYPE_IS_DECLARED 1

#define YYLLOC_DEFAULT(Current, Rhs, N) \
   do \
   { \
      if (YYID (N)) \
      { \
         (Current).sLine(YYRHSLOC (Rhs, 1)._line); \
         (Current).sLineEnd(YYRHSLOC (Rhs, 1)._line_end); \
         (Current).sColStart(YYRHSLOC (Rhs, 1)._column_start); \
         (Current).sColEnd(YYRHSLOC (Rhs, N)._column_end); \
         (Current).sFile(YYRHSLOC(Rhs, 1)._file); \
      } \
      else \
      { \
         (Current).sLine(YYRHSLOC (Rhs, 0)._line); \
         (Current).sLineEnd(YYRHSLOC (Rhs, 0)._line_end); \
         (Current).sColStart(YYRHSLOC (Rhs, 0)._column_end); \
         (Current).sColEnd(YYRHSLOC (Rhs, 0)._column_end); \
         (Current).sFile(NULL); \
      } \
   } \
   while (YYID (0))
}

%code {
extern int yylex();

void yyerror(fs::FileManager& fm, ast::node::Node* ast,
   st::SymbolTable& symbols,
   ::mem::log::Logger* logger, // Type ambiguity for gcc-c++ 4.2.1 on FreeBSD
   fs::File* file,
   const char *s)
{
   fs::position::Position* pos = new fs::position::Position();
   pos->sFile(file);

   log::Message* msg = new log::Error();
   msg->sMessage("Syntax error");
   msg->sDescription(s);
   msg->sPosition(pos);
   logger->log(msg);
}
}

%code requires {
}

%union {
   int integer;
   char* text;
   ast::node::Node* binary_node;
   ast::node::Node* node;
   ast::node::Text* text_node;
}

%code {
}


%locations
%token T_AMPERSAND
%token T_AROBASE
%token T_AND
%token T_CLASS
%token T_COMMA
%token T_CP
%token T_DEDENT
%token T_DOT
%token T_ELSE
%token T_EQ
%token T_IF
%token <text> T_ID
%token T_INDENT
%token T_INTERFACE
%token T_LBRACKET
%token T_LITERAL_FLOAT
%token T_LITERAL_HEX
%token <text> T_LITERAL_INT
%token <text> T_LITERAL_NUMBER
%token T_NEW
%token T_NEWLINE
%token T_OP
%token T_OR
%token T_PASS
%token T_PATCH
%token T_PRIMITIVE
%token T_OBJECT
%token T_RBRACKET
%token T_RARR
%token <text> T_STRING
%token T_USE
%token T_WHITESPACE
%token T_LEFT_BINARY_OP
%token T_RETURN
%token T_SEMICOLON
%token T_WHILE
%token T_SELF
%token T_BANG
%token T_HASH
%token T_DOTDOTDOT

// Lower precedence first
%left <node> T_AND T_OR
%left <node> T_EQ_EQ T_GT T_RARR_EQ T_LT T_RARR T_LARR_EQ
%left <node> T_MINUS T_PLUS
%left <node> T_MUL T_DIV
%left <node> T_MUL_MUL T_MODULO
%left <node> T_MINUS_MINUS T_PLUS_PLUS
%left <node> T_DOT

%type <node> binary_expr
%type <text_node> binary_operator
%type <text_node> bool_operator
%type <text_node> comp_operator
%type <text_node> math_operator
%type <node> block
%type <node> call
%type <node> class_declaration
%type <node> class_members
%type <node> compound_statement
%type <node> dot_expr
%type <node> expr
%type <node> expr_list
%type <node> function_declaration
%type <node> function_declaration_parameter
%type <node> function_declaration_parameter_list
%type <node> function_name
%type <text_node> id
%type <node> if
%type <node> literal
%type <node> members_declarations
%type <node> member_declaration
%type <node> return_statement
%type <node> simple_statement
%type <node> statement
%type <node> statements
%type <node> type_name
%type <text_node> use
%type <node> variable_assignment
%type <node> variable_declaration
%type <node> while
%type <node> qualified_id
%type <text_node> use_file
%type <text_node> metadata

%%

input :
   /* empty */
   | input T_NEWLINE
   | input T_DEDENT
   | input T_WHITESPACE T_NEWLINE
   | input use
   {
      ast->pushChild($2);
   }
   | input class_declaration
   {
      ast->pushChild($2);
   }
   | input function_declaration
   {
      ast->pushChild($2);
   }


use:
   T_USE use_file
   {
      $$ = new ast::node::Use();
      $$->sValue($2->gValue());
      $$->setPosition(new fs::position::Range(@1, @2));
      delete $2;
   }

use_file :
   T_ID
   {
      $$ = new ast::node::Text();
      $$->sValue($1);
   }
   | use_file T_DOT T_ID
   {
      $$->sValue($$->gValue() + '.' + $3);
   }

metadata :
   T_HASH T_ID T_NEWLINE
   {
      $$ = new ast::node::Text();
      $$->sValue($2, strlen($2));
   }

//=============================================================================
// CLASS
//=============================================================================

class_declaration:
   T_CLASS id class_members
   {
      ast::node::Class* cls = new ast::node::Class();

      cls->sValue($2->_value);
      cls->eat($3);
      cls->setPosition(new fs::position::Range(@1, @3));
      delete $2;
      delete $3;
      $$ = cls;
   }
   | T_CLASS id T_LT id class_members
   {
      ast::node::Class* cls = new ast::node::Class();

      cls->sValue($2->_value);
      cls->eat($5);
      cls->pushChild($4);
      cls->setPosition(new fs::position::Range(@1, @3));
      delete $2;
      delete $5;
      $$ = cls;
   }

class_members:
   T_NEWLINE T_INDENT members_declarations T_DEDENT
   {
      $$ = new ast::node::Block();
      $$->setPosition(new fs::position::Range(@3, @3));
      $$->eat($3);
      delete $3;
   }


//=============================================================================
// FUNCTION
//=============================================================================

function_name:
   T_ID
   {
      ast::node::Func* func = new ast::node::Func();
      func->sValue($1, strlen($1));
      $$ = func;

      free($1);
   }
   | metadata T_ID
   {
      Metadata* md = new Metadata();
      md->set($1->gValue(), "");

      ast::node::Func* func = new ast::node::Func();
      func->sValue($2, strlen($2));
      func->setMetadata(md);
      $$ = func;

      delete $1;
   }

function_declaration:
   //------------------------------------------------------------------------//
   // VIRTUAL FUNCTIONS                                                      //
   //------------------------------------------------------------------------//

   // Virtual function : no parameters, return type
   // Ex: my_function_name() -> my_return_type
   function_name T_OP T_CP T_RARR type_name T_NEWLINE
   {
      ast::node::Func* n = static_cast<ast::node::Func*>($1);
      n->pushChild($5);
      n->setPosition(@$.copy_range());
      $$ = (ast::node::Node*)n;
   }
   // Virtual function : parameters, return type
   // Ex: my_function_name(my_variable :my_type) -> my_return_type
   | function_name T_OP function_declaration_parameter_list T_CP T_RARR type_name T_NEWLINE
   {
      $3->setPosition(new fs::position::Range(
         *($3->getChild(0)->_position),
         *($3->getChild($3->_child_count-1)->_position)));

      ast::node::Func* n = static_cast<ast::node::Func*>($1);
      n->pushChildren($3, $6);
      n->setPosition(@$.copy_range());
      $$ = (ast::node::Node*)n;
   }

   //------------------------------------------------------------------------//
   // NORMAL FUNCTIONS                                                       //
   //------------------------------------------------------------------------//
   // Ex: my_function_name() -> my_return_type
   | function_name T_OP T_CP T_RARR type_name block
   {
      ast::node::Func* n = static_cast<ast::node::Func*>($1);
      n->pushChildren($5, $6);
      n->setPosition(@$.copy_range());
      $$ = (ast::node::Node*)n;
   }
   // Ex: my_function_name(my_variable :my_type) :my_return_type
   | function_name T_OP function_declaration_parameter_list T_CP T_RARR type_name block
   {
      $3->setPosition(new fs::position::Range(
         *($3->getChild(0)->_position),
         *($3->getChild($3->_child_count-1)->_position)));

      ast::node::Func* n = static_cast<ast::node::Func*>($1);
      n->pushChildren($3, $6, $7);
      n->setPosition(@$.copy_range());
      $$ = (ast::node::Node*)n;
   }


function_declaration_parameter_list:
   function_declaration_parameter
   {
      $$ = new ast::node::Node();
      $$->setKind(ast::node::Kind::FUNCTION_PARAMETERS);
      $$->pushChild($1);
   }
   | function_declaration_parameter_list T_COMMA function_declaration_parameter
   {
      $$->pushChild($3);
   }
   | function_declaration_parameter_list T_COMMA T_DOTDOTDOT function_declaration_parameter
   {
      $$->pushChild($4);
   }

function_declaration_parameter:
   id T_SEMICOLON type_name
   {
      $$ = new ast::node::Node();
      $$->setKind(ast::node::Kind::FUNCTION_PARAMETERS);
      $$->pushChildren($1, $3);
      $$->setPosition(new fs::position::Range(@1, @3));
   }

//===========================================================================//
// CONTROL FLOW                                                              //
//===========================================================================//

if:
   //------------------------------------------------------------------------//
   // SIMPLE IF                                                              //
   //------------------------------------------------------------------------//
   T_IF expr block
   {
      $$ = new ast::node::If();
      $$->pushChildren($2, $3);
      $$->setPosition(new fs::position::Range(@1, @2));
   }
   //------------------------------------------------------------------------//
   // IF / ELSE                                                              //
   //------------------------------------------------------------------------//
   | T_IF expr block T_ELSE block
   {
      $$ = new ast::node::If();
      $$->pushChildren($2, $3, $5);
      $$->setPosition(new fs::position::Range(@1, @5));
   }

while:
   T_WHILE expr block
   {
      $$ = new ast::node::While();
      $$->pushChildren($2, $3);
      $$->setPosition(new fs::position::Range(@1, @3));
   }

block:
   T_NEWLINE T_INDENT statements T_DEDENT
   {
      $$ = new ast::node::Block();
      $$->setPosition(new fs::position::Range(@3, @3));
      $$->eat($3);
      delete $3;
   }

statements:
   statement
   {
      assert ($1 != NULL);
      $$ = new ast::node::Node();
      $$->pushChild($1);
   }
   | statements statement
   {
      if ($$ == 0)
      {
         $$ = new ast::node::Node();
      }
      $$->pushChild($2);
   }

statement:
   expr T_NEWLINE
   {
      $$ = $1;
   }
   | simple_statement
   {
      $$ = $1;
   }
   | compound_statement
   {
      $$ = $1;
   }

compound_statement:
   if
   | while

simple_statement:
   variable_declaration
   | variable_assignment
   | return_statement

return_statement:
   T_RETURN expr T_NEWLINE
   {
      $$ = new ast::node::Return();
      $$->pushChild($2);
   }


members_declarations:
   member_declaration
   {
      $$ = new ast::node::Node();
      $$->pushChild($1);
   }
   | members_declarations member_declaration
   {
      $$->pushChild($2);
   }

member_declaration:
   // Ex: my_variable :my_type
   id T_SEMICOLON type_name T_NEWLINE
   {
      ast::node::Field* field = new ast::node::Field();
      field->setPosition(@$.copy_range());
      field->pushChildren($1, $3);

      $$ = (ast::node::Node*)field;
   }

type_name :
   qualified_id
   {
      $$ = static_cast<ast::node::Node*>($1);
   }

variable_assignment :
   expr T_EQ expr T_NEWLINE
   {
      ast::node::VarAssign* n = new ast::node::VarAssign();
      n->setPosition(@$.copy_range());
      n->pushChildren($1, $3);
      $$ = (ast::node::Node*)n;
   }

variable_declaration :
   // Ex: my_variable :my_type
   id T_SEMICOLON type_name T_NEWLINE
   {
      ast::node::VarDecl* n = new ast::node::VarDecl();
      n->setPosition(@$.copy_range());
      n->pushChildren($1, $3);
      $$ = (ast::node::Node*)n;
   }
   // Ex: my_variable := my_function()
   | id T_SEMICOLON T_EQ expr T_NEWLINE
   {
      ast::node::Node* ty_place_holder = new ast::node::Node();
      ty_place_holder->setKind(ast::node::Kind::PLACE_HOLDER);
      ty_place_holder->setPosition(@3.copy_range());

      ast::node::VarDecl* n = new ast::node::VarDecl();
      n->pushChildren($1, ty_place_holder, $4);
      n->setPosition(@$.copy_range());
      $$ = (ast::node::Node*)n;
   }
   // Ex: my_variable :my_type = my_function()
   | id T_SEMICOLON type_name T_EQ expr T_NEWLINE
   {
      ast::node::VarDecl* n = new ast::node::VarDecl();
      n->setPosition(@$.copy_range());
      n->pushChildren($1, $3, $5);
      $$ = (ast::node::Node*)n;
   }

id :
   T_ID
   {
      $$ = new ast::node::Text();
      $$->setKind(ast::node::Kind::ID);
      $$->setPosition(@$.copy_range());
      $$->sValue($1, strlen($1));

      free($1);
   }

qualified_id :
   id
   {
      ast::node::FinalId* n = new ast::node::FinalId();
      n->sValue($1->gValue());
      delete $1;
      $$ = static_cast<ast::node::Text*>(n);
   }
   | qualified_id T_DOT id
   {
      $$ = new ast::node::Dot();
      $$->pushChildren($1, $3);
      $$->setPosition(@$.copy_range());
   }

dot_expr :
   T_OP expr T_CP T_DOT id
   {
      $$ = new ast::node::Dot();
      $$->setPosition(@$.copy_range());
      $$->pushChildren($2, $5);
   }

expr :
   literal
   {
      $$ = $1;
   }
   | dot_expr
   {
      $$ = $1;
   }
   | binary_expr
   {
      $$ = (ast::node::Node*)$1;
   }
   /* ex: (1 + 2 + 3) */
   | T_OP expr T_CP
   {
      $$ = new ast::node::Node();
      $$->setKind(ast::node::Kind::GROUP);
      $$->pushChild($2);
   }
   | qualified_id
   {
      $$ = static_cast<ast::node::Node*>($1);
   }
   | call
   {
      $$ = (ast::node::Node*)$1;
   }
   | T_AMPERSAND expr
   {
      $$ = new ast::node::Node();
      $$->setKind(ast::node::Kind::AMPERSAND);
      $$->pushChild($2);
   }
   | T_NEW type_name
   {
      $$ = new ast::node::New();
      $$->setPosition(@$.copy_range());
      $$->pushChild($2);
   }

bool_operator:
   T_AND
   {
      $$ = new ast::node::Text();
      $$->setKind(ast::node::Kind::OP_AND);
   }
   | T_OR
   {
      $$ = new ast::node::Text();
      $$->setKind(ast::node::Kind::OP_OR);
   }

comp_operator:
   // ex: true == false
   T_EQ_EQ
   {
      ast::node::BinaryOp* op = new ast::node::BinaryOp();
      op->setKind(ast::node::Kind::OP_EQ_EQ);
      $$ = static_cast<ast::node::Text*>(op);

   }
   // ex 1 < 2
   | T_LT
   {
      $$ = new ast::node::Text();
   }
   // ex: 1 <= 2
   | T_LARR_EQ
   {
      $$ = new ast::node::Text();
   }
   // ex: 1 > 2
   | T_GT
   {
      $$ = new ast::node::Text();
   }
   // ex: 1 >= 2
   | T_RARR_EQ
   {
      $$ = new ast::node::Text();
   }

math_operator:
   // ex: 1 + 2
   T_PLUS
   {
      $$ = new ast::node::Text();
      $$->setKind(ast::node::Kind::OP_PLUS);
   }
   | T_MINUS
   {
      $$ = new ast::node::Text();
      $$->setKind(ast::node::Kind::OP_MINUS);
   }
   | T_MUL
   {
      $$ = new ast::node::Text();
      $$->setKind(ast::node::Kind::OP_MUL);
   }

binary_operator:
   bool_operator | comp_operator | math_operator

binary_expr:
   expr binary_operator expr
   {
      $2->pushChildren($1, $3);
      $2->setPosition(@$.copy_range());
      $$ = $2;
   }


expr_list :
   expr
   {
      $$ = new ast::node::Node();
      $$->setKind(ast::node::Kind::EXPRESSION_LIST);
      $$->pushChild($1);
   }
   | expr_list T_COMMA expr
   {
      if ($$ == 0)
      {
         $$ = new ast::node::Node();
         $$->setKind(ast::node::Kind::EXPRESSION_LIST);
      }
      $$->pushChild($3);
   }

call :
   /* ex: my_func() */
   qualified_id T_OP T_CP
   {
      $$ = new ast::node::Call();
      $$->setPosition(new fs::position::Range(@1, @3));
      $$->pushChild($1);
   }
   /* ex: my_func(1, 2, 3) */
   | qualified_id T_OP expr_list T_CP
   {
      $3->setPosition(@3.copy_range());
      $$ = new ast::node::Call();
      $$->setPosition(new fs::position::Range(@1, @4));
      $$->pushChildren($1, $3);
   }

literal :
   T_LITERAL_NUMBER
   {
      char c_val = 0;
      short s_val = 0;
      int i_val = 0;

      size_t nb_len = strlen($1);
      char int_ty = $1[nb_len-1];
      char sign_ty = $1[nb_len-2];
      if (sign_ty != 'u') nb_len--;

      char* nb = static_cast<char*>(malloc(sizeof(char) * nb_len + 1));
      strncpy(nb, $1, nb_len);
      nb[nb_len] = '\0';

      switch (int_ty)
      {
         case 'c':
            if (mem::number::getCharFromString(nb, c_val))
            {
               ast::node::Number* s_node = new ast::node::Number();
               s_node->setChar(c_val);
               s_node->setExprType(symbols._core_types.gCharTy());
               $$ = s_node;
            }
            break;

         case 's':
            if (mem::number::getShortFromString(nb, s_val))
            {
               ast::node::Number* s_node = new ast::node::Number();
               s_node->setShort(s_val);
               s_node->setExprType(symbols._core_types.gShortTy());
               $$ = s_node;
            }
            break;

         case 'i':
            if (mem::number::getIntFromString(nb, i_val))
            {
               ast::node::Number* i_node = new ast::node::Number();
               i_node->setInt(i_val);
               i_node->setExprType(symbols._core_types.gIntTy());
               $$ = i_node;
            }
            break;

         defaut:
            printf("Strange number in source");
            assert(false);
      }

      assert ($$ != NULL);

      if ($$ != NULL)
      {
         $$->setPosition(@1.copy_range());
      }
      else
      {
         assert(false);
         //FIXME Couldnt fit this value into a numeric type, so should fail
      }
      free(nb);
      free($1);
   }
%%

#include "mem/ast/node/Node.hpp"
